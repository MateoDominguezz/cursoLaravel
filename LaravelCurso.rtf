{\rtf1\ansi\ansicpg1252\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil\fcharset2 Symbol;}}
{\colortbl ;\red255\green0\blue0;}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\qc\b\f0\fs40\lang10 Laravel\b0\fs36\par
\b Root\b0\par

\pard\sa200\sl276\slmult1\fs32 Esta clase dispone de metodos estaticos, para utilizar metodos estaticos se utiliza :: , estas rutas son las mas importantes:\par
\b Route::view(); \b0 // Mostrar vista\par
\b Route::get(); \b0 // Agarrar datos\par
\b Route::post(); \b0 // Crear datos\par
\b Route::put(); \b0 // Editar datos\par
\b Route::delete(); \b0 // Eliminar datos\par
\b Route::resource(); \b0 // Resume los endpoint de la api.\par
Para que funcione  la ruta, necesitan dos parametros:\par
\b Route::post("ruta/post", ControlladorDeLaRuta::class);\b0\par
Si utilizas un controlador, este se tiene que importar con use.\par
Si utilizas una \b vista estatica \b0 (view), se puede hacer asi:\par
\b Route::view("/","index");\b0\par
A cada ruta le podes \b asociar un nombre \b0 con ->name("nombre"), Ejemplo.\par
\b Route::view("/","index")->name("inicio");\b0\par
\par

\pard\sa200\sl276\slmult1\qc\b Blades\b0\par

\pard\sa200\sl276\slmult1 Si tenes vistas que son iguales, se suele usar un layout, este lo que hace es para ahorrar codigo.\par
Para definir una seccion en una plantilla, se utiliza \b @yield\b0 . Ejemplo: @yield("titulo").\line Para llamarlo en otro archivo primero hay que importarlo con\b : @extends("layout.blade")\b0\par
Para inyectar el contenido que guardaste en los yield, se utiliza: @section("titulo", "NombreDelTitulo")\par
Si queres ingresar contenido en html, con los yields, se utiliza asi:\par
@section("contenido")\par
// Todo el contenido de HTML\par
@endsection\par
\par
Para crear un componente aislado, y incluirlo a el layout base, se hace con @include("carpeta.nav")\par
\par

\pard\sa200\sl276\slmult1\qc\b Nombre de Rutas\b0\par

\pard\sa200\sl276\slmult1 Si le pones \b nombre a las rutas\b0 , se pueden utilizar ese nombre que le pusiste a la ruta en href. Ej:\par
en web: \b Route::view("/", \cf1 "index"\cf0 )->name("index");\par
\b0 en la plantilla: <li><a href=\cf1\b "\{\{route("index")\}\}"\cf0\b0 >Inicio</a></li>\par
Sirve por si modificas la ruta, gracias a que le pones un nombre esta ruta va a seguir con el mismo nombre.\par
\par

\pard\sa200\sl276\slmult1\qc\b Componentes Blade\b0\par

\pard\sa200\sl276\slmult1 Sirve para definir los contenido de un archivo padre, siendo el archivo hijo, esto sirve para que mostrar lo que se necesite.\par
Para realizar componentes blade, primero se crea una carpeta \b _components\b0 , ahi es donde van a ir todos los componentes, para \b crear \b0 un \b espacio \b0 donde se pueda \b escribir contenido\b0 , hay que crear una variable abriendo doble llave y nombre asi: \b\{\{$variable\}\}\b0 . Creas el componente ej:\par
<div> \par
    <h3>\{\{ $card_title \}\}</h3>\par
    <p>\{\{ $card_content \}\}</p>\par
</div>\par
Para \b llamarlo de una vista \b0 se tiene que llamar a el componente asi \b @component("carpeta.card")\b0 , para \b poner \b0 las \b variables \b0 que se definieron antes, se utiliza \b @slot("nombreVariable", "Contenido")\b0 ,\par
Si le queres agregar contenido html, es con @slot("content")\par
\tab // Contenido html\par
@endslot\par
Ejemplo de todo:\par
@component("_components.card")\par
        @slot("card_title", "About 1")\par
        @slot("card_content","About me resumed")\par
@endcomponent\par
\par

\pard\sa200\sl276\slmult1\qc\b Recursos estaticos\par

\pard\sa200\sl276\slmult1\b0 Para poner imagenes o videos, se suele poner en la carpeta public, crear una carpeta assets y img. Esto se hace cuando queres mostrar informacion estatica. Para utilizar lo que pongas ahi en un blade, primero tenes que tener la etiqueta imga con src, adentro de src, se le va a indicar que va a ser estatico, y una vez realizado eso, se pone la url ej:\par
<img src="\{\{asset("assets/img/ej.jpg")\}\}">\par
Esto tambien se puede hacer con un css, es lo mismo que la imagen, pero se tendria que crear una nueva carpeta css, y en el layout principal llamar a ese css asi:\par
<link rel="stylesheet" href="\{\{ asset("assets/css/style.css") \}\}">\par
\par

\pard\sa200\sl276\slmult1\qc\b Migrations\par

\pard\sa200\sl276\slmult1\b0 Para poder desplegar todas las migraciones que tenes en el sistema en la terminal se pone: \b php artisan migrate\b0\par
Para generar tablas para la base de datos se utiliza: \par
\b php artisan make:migration SociosTable\par
timestamps(): \b0 Este te crea dos nuevos atributos a la tabla, el primero: cuando se creo una tabla, el segundo: cuando se actualizo esa tabla\par
\b string("nombre", 100)\b0 : Es un VARCHAR, y lo que va al lado es la cantidad maxima de caracteres que se le permite\par
\b $table->string("dni", 8)->unique(): \b0 unique sirve para decirle que el campo que se cree, no puede ser igual a otro campo ua creado\par
\b text("descripcion")->nulleable()\b0 : Se suele poner cuando un campo necesita mucho texto, nulleable() sirve para decirle que se puede poner ese atributo sin nada como nulo\par
\b $table->enum("estado", ["aprobado,desaprobado"])->default("desaprobado"): \b0 Sirve para poner datos especificos y solo esos datos se van a poder utilizar y el \b default("desaprobado")\b0 , sirve para que cuando se cree una tabla, en el campo enum aparezca desaprobado\par
\b $table->boolean("hecho")->default(false)\b0 : Es para poner v o f\par
\b $table->integer("nota"): \b0 Es para poner un numero entero\par
\b $table->unsignedInteger("nota"): \b0 Es para poner un entero que sea solo positivo\par
\b $table->bigInteger("ejemplo"): \b0 Sirve para poner enteros de muchos numeros\par
\b $table->float("precio"): \b0 Es para poner un numero con decimal\par
\b $table->decimal('precio', 10, 2)->default(0.00): \b0 Es como el float, pero mas preciso\par
\par

\pard\sa200\sl276\slmult1\qc\b Roolback\b0\par

\pard\sa200\sl276\slmult1 Esto sirve para decirle a la base de datos, che me equivoque necesito que vuelvas a donde estabas antes de hacer el migration, esto sirve por si te equivocas o tenes que cambiar algun atributo de la tabla, esta es la opcion que se utiliza casi siempre, el comando es: \b php artisan migrate:rollback\b0\par
Para tirar todas las migraciones que se hicieron es: \par
\b php artisan migrate:reset\b0\par
Para tirar atras las migraciones que vos queres, eso va a depender de el batch que va a tener cada tabla (esto se puede mirar en la tabla migration que esta adentro de la base de datos), eso se hace con el comando: \b php artisan migrate:rollback --batch=3\b0\par
Si queres tirar todas las tablas y que aparezcan devuelta se utiliza el comando: \b php artisan migrate:refresh\par
\par

\pard\sa200\sl276\slmult1\qc Actualiza Tabla\par
Desde Otra Tabla\par

\pard\sa200\sl276\slmult1\b0 Para \b actualizar \b0 una \b tabla\b0 , cuando ya tenes muchas relaciones, como clave foraneas o clave primaria compuestas, se suele \b crear \b0 una \b tabla \b0 para poder \b actualizar \b0 los datos o eliminarlos, se crea la tabla con \b php artisan make:migration ActualizarNotasTabla\b0 .\par
Una vez que tenemos eso, nos va a aparecer vacio \b la funcion up(). \b0 En este caso tenemos que \b agregarle Schema::table \b0 y \b la tabla \b0 que queremos \b actualizar\b0 , en esta tabla se ponen \b solo los atributos \b0 que se tengan que \b agregar o eliminar\b0 .Para  agregar un atributo se pone $table->string("autor"), como si es una tabla normal. Para \b eliminar \b0 un \b atributo \b0 se utiliza: \b $table->dropColumn(["descripcion"]); \b0\par
La \b funcion down(), \b0 va a estar vacia, en esta lo que se pone son los \b atributos \b0 que pusimos en la \b tabla up(), \b0 en este caso \b iria en down(): Schema::dropColumn(["autor"])\par
\par

\pard\sa200\sl276\slmult1\qc Models\b0\par

\pard\sa200\sl276\slmult1 Los models sirven para poder interactuar con la base de datos. El Model es el \b modelo de persistencia \b0 porque contiene la l\'f3gica de negocio como las operaciones de base de datos.\par
Para poder interactuar, se debe \b crear \b0 un \b modelo \b0 con el comando: \b php artisan make:model Note\b0\par
Siempre el modelo va en singular, pero en la migracion va en plurar. Si no respetas la \b convencion \b0 de nombres, vas a tener que decirle a el modelo con \b que tabla va a trabajar\b0 , poniendo adentro de la clase el comando: \b protected $table = "nombreTabla";\par
$protected $fillable= [];\b0\par
Para que sirve el \b protected $fillable\b0 , sirve para decirle que campos del objeto van a poder ser cumplimentados, en pocas palabras \b sirve para decirle al sistema que atributos permite insertar\b0 , porque puede haber atributos que se generen automaticamente, como por ejemplo el id.\par
    protected $fillable = \par
    [\par
        "titulo",\par
        "descripcion",\par
        "fecha_entrega",\par
        "hecho"\par
    ];\par
Otro mas es el \b protected $guarded\b0 , es lo \b contrario a $fillable\b0 , este dice que atributos son protegidos, (No es necesario, si ya hiciste el $filable)\par
Otro mas es el \b protected $casts\b0 , este sirve para decirle a los \b atributos de que tipo son\b0 , ej si es una fecha este tiene que ser del tipo date ej:\par
protected $casts = [\par
        "fecha_entrega"=>"date"\par
    ];\par
Ventajas:\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1 Conversi\'f3n autom\'e1tica de tipos\par
{\pntext\f1\'B7\tab}Mejor consistencia de datos\par
{\pntext\f1\'B7\tab}Facilita el trabajo con fechas, booleanos, etc.\par

\pard\sa200\sl276\slmult1 Otro mas es el \b protected $hidden\b0 , Sirve para decirle que atributos no queres mostrar, cuando mostras todos los datos, este se suele usar para las contrase\'f1as. Tambien tenes lo contrario que es \b protected $visible =[]; \b0 Lo que hace es decirle que \b atributos \b0 se \b quieren mostrar\b0\par
\par

\pard\sa200\sl276\slmult1\qc\b Atajos de comandos en TERMINAL\par

\pard\sa200\sl276\slmult1\b0 Para crear un \b modelo y una migracion \b0 el comando es:\par
\b php artisan make:model Socio -m\b0\par
\par

\pard\sa200\sl276\slmult1\qc\b Controladores\b0\par

\pard\sa200\sl276\slmult1 Lo principal es saber el mecanismo casi siempre es: \b Una ruta esta asociada a un controlador, este controlador esta asociado a un model y el model esta asociociado a una migracion\b0 .\par
Para \b crear \b0 un \b controlador \b0 se utiliza:\par
\b php artisan make:controller UserController\b0\par
Los controlladores utilizan camelcase, el nombre descriptivo y despues el Controller.\par
Sirve para definir funciones, que cada una va a estar destinada a controlar una vista.\par
Para poder relacionarse con las vistas, primero hay que \b exportarlo \b0 con \b use\b0 , en este caso es \b use App\\Http\\Controllers\\UserController; \b0 este necesita ser incluido en las rutas asi:\par
\b Route::get("/", [UserController::class, "index"]);\b0\par
Como se puede ver va primero el controlador con ::class y el otro parametro es que funcion solicitamos de ese controlador.\par
Adentro del controlador, se suele poner una funcion index(), que esta va a ser la principal, en esta se suele devolver mostrar todos los usuarios, en este caso devolvemos una vista asi:\par
public function index()\{\par
\tab return view("user.index");\par
\}\par
\b return view\b0 , sirve para decirle que se va a \b retornar una vista\b0\par
El controlador se crea para poder poner acciones y logica en los modelos, para despues mostrarlos en una vista,\par
Para poder laburar con \b Modelos \b0 lo primero es \b importarlo \b0 con \b use\b0 , en este caso es: \b use App\\Models\\User;\b0\par
Para \b recuperar \b0 todos los \b datos \b0 que tenemos en el User, \b utilizamos \b0 el modelo y metodos estaticos, para esto necesitamos \b ORM\b0 . Tenemos estos ORM:\par
\b User::all(); \b0 Con esto le decimos traeme \b todos los \b0 datos de la tabla user.\par
Una ves que tenemos esto, necesitamos pasarle \b esta variable a la vista\b0 , en este caso todos los usuarios, para pasarlos se utiliza un \b segundo argumento \b0 llamado \b compact("user")\b0 , asi seria:\par
\b return view("user.index", compact("users"));\b0\par
\b En la vista \b0 para poder mostrar todos los usuarios se utilizan \b directivas blade\b0 , en este caso el \b @foreach\b0 , Ejemplo:\par
    @foreach ($users as $user)\par
        <h2>Nombre: \{\{ $user->name \}\} </h2>\par
    @endforeach\par
Podemos recorrer los usuarios porque nos lo pasa el controlador, sino no se puede.\par
\par

\pard\sa200\sl276\slmult1\qc\b Directivas Selectivas\b0\par

\pard\sa200\sl276\slmult1 Nos van a permitir mostrar o no cierta informacion, en funcion de si se cumple o no la directiva que le pongamos, unos ejemplos de directiva selectivas son: \b if, switch, else, case.\par
\b0 Un \b ejemplo \b0 de las \b dos directivas \b0 combinadas:\b\par
    @if($users->isEmpty())\par
\b0         <h1>No tenes ningun usuario registrado</h1>\b\par
    @else\par
\b0         <h1>Lista de usuarios</h1>\par
        \b @foreach ($users as $user)\par
\b0             <h2>Nombre: \{\{ $user->name \}\} </h2>\par
            <h2>Email: \{\{ $user->email \}\} </h2>\b\par
        @endforeach\par
    @endif\par
\b0 Un \b ejemplo mas compacto \b0 es:\par
    @forelse ($users as $user )\par
        <h1>User List</h1>\par
        <h2>Nombre: \{\{ $user->name \}\} </h2>\par
        <h2>Email: \{\{ $user->email \}\} </h2>       \par
    @empty\par
        <p>No tenes ningun usuario</p>\par
    @endforelse\par
\par

\pard\sa200\sl276\slmult1\qc\b Insertar datos en el controlador\b0\par

\pard\sa200\sl276\slmult1 Primero hay que crear una ruta, con el metodo, en el controlador creamos el metodo create, se para crear un usuario se utiliza: \par
public function create() \{\tab\par
\b\tab $user = new User;\b0\par
\}\par
Para ponerle \b datos manualmente \b0 se utiliza:\par
\b $user->name = "Mateo";\par
\b0 Asi quedaria la funcion con todos los atributos:\par
public function create() \{\tab\par
\b         $user = new User;\par
        $user->email = "mateo@gmail.com";\par
        $user->password = Hash::make("1234");\b0\par
\}\par
Para guardar los datos se utliza el metodo \b $user->save();\b0\par
Hay un comando que te ahorra todo estas lineas de codigo utilizando la clase estatica\b : User::create([]). \b0 Ejemplo:\par
\b User::create\b0 ([\par
            "name" => "Jose",\par
            "email" => "jose@gmail.com",\par
]);\par
En este caso, queremos que nos lleve a el index, que ya creamos se pone asi, le decimos que nos rediriga, a el index, que es asi:      \b return redirect()->route("user_index");\par
\b0\par

\pard\sa200\sl276\slmult1\qc\b Eloquent\b0\par

\pard\sa200\sl276\slmult1 Sirve para poner en el controlador, gracias a eloquent, condiciones en la busqueda de la base de datos (where), un ejemplo, necesitas mostrar solo a los mayores de 18, se puede hacer asi: \b $users = User:where("age",">",18)->get(); \b0 Se utiliza el get, porque el where devueleve un objeto no un array, tambien se pueden poner \b where enlazados\b0 , para poner mas de una consulta, ej: \par
\b $users = User:where("age",">",18)->where("zip_code", 7400)->get();\b0\par
Para meter un \b or\b0 , se utiliza el metodo \b orWhere\b0 , que va enlazado al primer where, sirve para decirle que queres que se \b cumpla por lo menos una\b0 : \par
\b $users = User:where("age",">",18)->orWhere("zip_code", 7400)->get();\b0\par
Tambien tenes para decirle en que orden queres los datos con el metodo: orderBy(), EJ, los user de mayor a menor:\par
\b $users = User::where("age",">",17)->orderBy("age","desc")->get();\par
\b0 Tambien tenes para ponerle un limite a la cantidad de registros que te trae, se hace con la propiedad limit(), ej: los 5 usuarios mas grandes:\par
\b $users = User::where("age",">",17)->orderBy("age","desc")->limit(5)->get();\b0\par
Para \b buscar \b0 un unico \b usuario\b0 , atravez de una id, se utiliza \b User::findOrFail(1); o User::find(1), \b0 la diferencia es que el findOrFail si no lo encuentra te manda un mensaje de error. ej:\par
\b $users= User::findOrFail(1);\b0\par
\par

\pard\sa200\sl276\slmult1\qc\b Sql RAW\b0\par

\pard\sa200\sl276\slmult1 Sirve para realizar las \b busquedas sin \b0 apoyarse en el \b ORM\b0 , sirve para poder realizar \b consultas SQL\b0 , para utilizar en el controlador se \b debe importar \b0 con use Illuminate\\Support\\Facades\\\b DB\b0 ; . Tenes dos maneras de utilizarlo como insercion o como mostrar datos. Y para poder utilizarlo se utiliza con DB:: , ejemplo:\par
Para mostrar datos:\par
\b $users = DB::table("users")\par
                    ->select(DB::raw("*"))\par
                    ->get();\par
\b0 Para insertar datos:\par
\b DB::insert("INSERT INTO users VALUES .. ");\b0\par
o tambien hay otra forma mas recomendada para insertar datos asi, esta es con table y insert que es asi:\par
DB::table('users')->insert([\par
\tab "name"=> "Pedro",\par
\tab "email" => "pedro@gmail.com",\par
]);\par

\pard\sa200\sl276\slmult1\qc\b\par
\fs36 CRUD, VALIDACION Y SESION\par
\fs32 Parametro Dinamicos en Rutas\par

\pard\sa200\sl276\slmult1\b0 Esto sirve para poder crear rutas dinamicas, en donde va la url, se pone con \{id\}, esto le dice a la url, che te voy a pasar un valor dinamico. Un ejemplo es:\par
\b Route::get("/product/\{id\}", [ProductController::class, "getById"])->name("product_id");\b0\par
Para indicar si queres que el \b atributo \b0 pueda ser \b opcional \b0 se le pone un \b ? \b0 al lado del id: \{id?\}\par
Para poder \b agarrar \b0 ese \b id\b0 , se tiene que hacer \b desde \b0 el \b controlador\b0 , cuando le indicas a la funcion que se enlaza, \b en \b0 los \b parentesis \b0 va el \b parametro dinamico \b0 en este caso es el $id, ej en el controlador:\par
\b public function getById($id) \{\par
\tab $note = Note::findOrFail($id);\par
          return view("note.id", compact("note"));\par
\}\par
\b0 Y para msotrarla en el blade, es como mostrar un dato, asi:\par
\b\{\{ $note->id \}\}\b0\par
Si pones que el parametro sea opcional en el controler le tenes que poner un valor por defecto asi:\par
\b public function index($id = 25)\b0\par
\par

\pard\sa200\sl276\slmult1\qc\b Crear un dato con CRUD en .blade\b0\par

\pard\sa200\sl276\slmult1 Primero en principal es en el formulario .blade, es crear un formulario normal, con todos los datos que necesita de entrada, adentro del form va el metodo post, pero en el \b action \b0 tenes que \b llamar \b0 a la \b ruta \b0 que va a hacer el post en mi caso es:\line\b <form method="POST" action= "\{\{ route("note_store")\}\}">\par
\b0 Una vez que haces eso, le tenes que decir al sistema, que ese formulario es propio del sistema, se le tiene que a\'f1adir la directiva: @csrf . Esto lo que hace es que le da un token, que permite identificar el formulario, se tiene que poner, sino no anda el formulario.\par
En el \b formulario\b0 , para que el metodo pueda \b recibir \b0 los \b valores \b0 de los \b inputs\b0 , hay que ponerle en el \b atributo name \b0 del input, el \b nombre \b0 de el \b atributo de la base de datos\b0 , para que despues lo pueda recibir el metodo.\fs36\par
\fs32 Ahora tenemos que \b ir \b0 a la \b carpeta \b0 de \b rutas \b0 entrar a \b web\b0 .php y \b crear \b0 la \b ruta \b0 con el metodo estatico \b post\b0 , Route::Post, asi:\par
\b Route::post("/note/store", ["NoteController::class", "store"])->name("note_store");\b0\par
Una vez que tenemos eso, tenemos que ir al NoteController y crear el metodo store, para que se pueda almacenar en la base de datos. \par
Pero esta \b funcion\b0 , necesita \b recepcionar datos\b0 , esto se hace en el parentesis de la funcion, se pone \b (Request $request)\b0 . Esto le dice al \b sistema \b0 que va a ser una \b funcion post\b0 , que va a tener una ruta post, que esta va a estar enviando una peticion al sistema, de esta forma se recepciona el contenido del formulario.\par
Para \b crear\b0 , se \b utiliza \b0 la funcion estatica \b Note::create\b0 , en esta si vos pones bien todos los nombres en el formulario, con una sola linea de codigo, se guardan los datos, asi:\par
\b Note::create($request->all());\b0\par
\par

\pard\sa200\sl276\slmult1\qc\b Editar\b0\par

\pard\sa200\sl276\slmult1\b Primero en web \b0 tenes que tener una \b ruta get\b0 , para poder mostrar el formulario, pero este get, \b necesita \b0 recibir los \b valores \b0 de la \b nota \b0 para poder mostrarlos, esto lo hace para saber que nota queres editar y para mostrar el valor de la nota en los inputs:\line\b Route::get("note/update/\{note\}", [NoteController::class, "update"])->name("note_update");\b0\par
\b Segundo \b0 tenes que crear la funcion para \b rediriguir a el formuario \b0 con los datos de la nota, esta funcion recibe un parametro nota asi: (Note $note), para poder mostrar la nota asi:\par
\b public function update(Note $note)\par
\{\par
\tab return view("note.update", compact("note"));\par
\}\par
\b0 Tercer paso crear el formulario update, una vez que tenemos el formulario, hay que hacer estos pasos: \line\b Primero\b0 : en el action: va la ruta que llama al metodo de actualizar que en este caso es note_edit, este va a tener que llamar a la nota, poniendole una coma en el note_edit, $note->id . Esto se hace asi para decirle a el metodo que nota se va a querer editar. asi quedaria: \b action= "\{\{ route("note_edit", $note->id)\}\}"\par
\b0 Pero para eso en \b web\b0 , tenes que \b crear \b0 una \b ruta \b0 de metodo \b put\b0 , esto sirve para \b indicarle \b0 a \b laravel \b0 que se va a \b editar \b0 una \b nota\b0 , asi quedaria la  ruta: \b Route::put("note/edit/\{note\}", [NoteController::class, "edit"])->name("note_edit");\par
Segundo\b0 : Como el metodo editar es PUT, en el formulario lo tenemos que indicar, esto se indica una vez ya creado el formulario, abajo se pone @method("PUT"), Esto le indica a laravel que ese formulario va a ser para editar.\par
\b Tercero\b0 : A cada campo que tenes un input, y queres que se edite, se le pone en le value el valor de ese campo especifico de la nota un ejemplo del titulo: value="\{\{ $note->title \}\}"\par

\pard\sa200\sl276\slmult1\qc\b Atualizacion de valor (CONTROLLER)\b0\par

\pard\sa200\sl276\slmult1 En el controller tenes que crear el metodo que va a actualizar la nota: Este tiene una particularidad, va a recibir dos parametros, un Request y Note. Asi se va a ver:\par
public funcion edit(Request $request, Note $note)\line Una vez que tenemos eso, se sigue con los parametros de adentro, el note se utiliza porque laravel en su interior te busca automaticamente la nota. y con el request recolectamos todos los datos de esa nota, para llamar al metodo a actualizar se hace asi:\par
\b $note->update($request->all());\b0\par
Esto le indica a laravel que se va a actualizar la nota, con el $request, recolecta todos los datos.\par
Despues de eso se redirigue al inicio.\par
asi: return redirect()->route("note_index");\par

\pard\sa200\sl276\slmult1\qc\b\par
Mostrar por ID\par

\pard\sa200\sl276\slmult1\b0 Primero tenes que crear la ruta, esta ruta va a necesitar el parametro \{note\}. Asi:\par
Route::get("note/ver/\{note\}", [NoteController::class, "view"])->name("note_view");\par
Segundo paso: poner el route, para que nos lleve a la vista de la nota en especifico, asi: \par
href="\{\{ route("note_view", $note->id) \}\}"\par
Esto lo que le dice a laravel, llevame a esta vista, y pintamela con los valores que tenga esta nota.\par
Tercer paso: En el controlador crear la funcion view, esta necesita el parametro (Note $note), porque al igual que el update, necesita recolectar la informacion de la nota, que se apriete. ahora se tiene que hacer que se rediriga al view, pero obviamente agregandole la variable $note asi:\par
return view("note_view", compact("note"));\par
Cuarto paso: Crear la vista para mostrar la informacion con .blade y para mostrar es lo mismo que se hace con el update, ejemplo:     \{\{$note->title\}\}\par
\par

\pard\sa200\sl276\slmult1\qc\b Eliminar\b0\par

\pard\sa200\sl276\slmult1 Para eliminar se tiene que crear un formulario en el boton, porque es el eliminado es una variacion a el create. se utiliza \b el @method("DELETE"). \b0 En el formulario se llama a la funcion que va a eliminar, y se le suma el parametro de nota asi: $note->id. Asi\b : <form method="POST"action="\{\{ route("note_delete", $note->id) \}\}">\b0\par
Se crea en la web, la ruta con el medoto delete asi:\par
\b Route::delete("note/delete/\{note\}", [NoteController::class, "delete"])->name("note_delete");\par
\b0 Y en el controlador como en el update, necesitamos el valor de la nota, gracias a esto podemos utilizar el metodo delete:\par
\b $note->delete();\par
\b0 Despues de esto redirigimos a la pnatalla principal con:\par
\b return redirect()->route("note_index");\b0\par
Asi quedaria toda la funcion:\par
\b public function delete(Note $note)\par
\{\par
        $note->delete();\par
        return redirect()->route("note_index");\par
\}\fs36\par

\pard\sa200\sl276\slmult1\qc\fs32 Funcion :Nombre\b0\par

\pard\sa200\sl276\slmult1 Siempre que se crean funciones en el controler.Esto sirve para decirle a laravel que vas a trabajar y si algun dia cambias el valor que das, te va a advertir laravel, para esto hay que decirle a laravel de que tipo van a ser ej:\par
Si tenes un redirect:\par
public function store(Request $request): RedirectResponse\par
Si retorna una vista:\par
public function view(Note $note): View\par
\par

\pard\sa200\sl276\slmult1\qc\b Validaciones\b0\par

\pard\sa200\sl276\slmult1 Esto sirve para, que cuando vos tengas que recibir algo, el sistema detecte si hay algo en la validacion que el usuario no cumple, El sistema no lo va a guardar en la base de datos. Estas validaciones se ponen en el create y update. Estas validaciones se pueden hacer de dos formas, en el controler o crear otro archivo con todas las validaciones. Primero en el controler:\par
Se utiliza el metodo validate(), esto sirve para ponerle las validaciones, a cada parametro asi seria:\par
$validated = $request->validate([\par
\tab "title" => "required|min:3| max:100",\par
\tab "description" => "required|min:5"\par
]);\par
Para seguir agregandole reglas se utiliza: "|".  \par
Esto si no se cumple envia un error y lanza un error al sistema, este error se le puede mostrar al usuario.\par
Opcion 2: La mejor Opcion\par
Para esta opcion, lo que se hace es que hacemos una Custom Request. Para crear una CustomRequest tenemos que ir a la terminal y crearla, esta se crea con el comando: \par
\b php artisan make:request Note/NoteRequest\b0\par
Una ves que estamos en la request, en la funcion que dice, \b authorize(), \b0  Esta funcion lo que hace es que le podes dar permisos dependiendo de que rol cumpla, un ejemplo: si es un administrador, que no le sirva esta autorizacion, esta adentro tiene un return false, este return false, lo cambiamos por un return true; Porque lo puede hacer calquiera en nuestro caso. \par
En la segunda funcion rules(), aca van nuestras validaciones, aca van todas las validaciones, la sacamos del NoteController y las pasamos aca. Pero para agarrar estos datos validados, en el PostController, primero hay que importarlo con el nombre que tenga y segundo en la funcion create o update van a recibir como parametro el \b NoteRequest $request\b0 , asi:\par
\b public function store(NoteRequest $request)\b0\par
Y para usarlo, se utiliza el metodo validated(), que lo que hace es que valida los datos de entrada, ejemplo:\par
Crear: Note::create($request->validated());\par
Update: $note->update($request->validated());\par
\par

\pard\sa200\sl276\slmult1\qc\b Manejo de Acciones\par
Errores\b0\par

\pard\sa200\sl276\slmult1 Esto sirve para mandarle el error al usuario. Para hacer esto, en el archivo NoteRequest se crea una nueva funcion messages, con todos los mensajes personalizados ej:\par
    public function messages(): array\par
    \{\par
        return [\par
            "title.required" => "El campo titulo es obligatorio",\par
            "title.min" => "El campo titulo debe tener al menos 3 \tab\tab   caracteres"\par
],\par
\}\par
Para mostrar estos mensajes, hay que ir a el formulario, para mostrarlos, para el manejo de errores existe la directiva @error().\par
Para mostrar errores por seccion se utiliza asi, con la variable \b $message\b0 , recolectamos todos los errores y dependiendo de que error queres mostrar, en @error, tenes que especificar de que input estas hablando, un ejemplo del campo titulo:\par
@error("title")\par
\tab <p class="text-danger"> \{\{$message\}\}</p>\par
@enderror\par
Tambien se pueden poner los errores en un apartado, se utiliza la variable $errors esto es mas general, con un array y mostrarlo en la pantalla asi:\par
    @if($errors->any())\par
        <ul>\par
        @foreach ($errors->all() as $message)\par
            <li> <p class="text-danger"> \{\{ $message \}\} </p> </li>\par
        @endforeach()\par
        </ul>\par
    @endif\par
\par

\pard\sa200\sl276\slmult1\qc\b Manejo de Acciones\par
Satisfactoriamente\b0\par

\pard\sa200\sl276\slmult1 Para mostrarle al usuario, cuando realizo la accion bien, se utilizan flash messages, que se muestrar una sola ves cuando hacemos una accion en concreto, Esto se suele aplicar en la base de  tu layout, porque si hay algun mensaje, estes donde estes te lo muestra.\par
Primero como mandar el mensaje: Para mandar mensajes personalizados, se hace en el controler,utilizando el metodo with("success", "Mensaje de exito"), este se utiliza al finalizar cuando retorna algo un ejemplo para el metodo de crear:\par
return redirect()->route("note_index")->with("success", "Nota creada con exito");\par
Como \b mostrarlo \b0 en la \b vista\b0 , se suele crear un archivo solo para los mensajes de exito. Para recibir el mensaje se \b utiliza \b0 el \b metodo get\b0  \b de la session\b0 , que seria asi: \b Session::get()\b0 , y adentro del get se utiliza el \b nombre de la variable\b0  que introduciste en el \b with\b0 , en este caso es el success, y se suele utiliza la directiva \b @if\b0 . Asi quedaria:\par
\b @if($message= Session::get("success"))\par
\tab <p> \{\{ $message \}\}</p>\par
@endif\par

\pard\sa200\sl276\slmult1\qc\par
Ruta Resources\par

\pard\sa200\sl276\slmult1\b0 Sirve para \b abrebiar \b0 todo el contenido de un \b crud\b0 , de un mismo \b modelo\b0 , se utiliza asi:\par
\b Route::resource("/post", PostController::class);\b0\par
Esto lo que le dice a laravel, che creame una ruta para el crud, estas rutas se pueden ver con: \b php artisan route:list\b0\par
Para que laravel te cree automaticamente todas las funciones de el crud en el controler se utiliza --resource abreviado es -R\par
Asi seria el comando:\par
php artisan make:model Product -mcrR o lo mismo:\par
php artisan make:model Product -a\par
Y con Form Request:\par
php artisan make:model Product -a --request\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\fs22\par
}
 